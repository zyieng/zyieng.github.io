<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RBAC</title>
    <url>/2021/06/09/RBAC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>RBAC</category>
      </categories>
      <tags>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>umi-简介</title>
    <url>/2021/05/28/umi-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>umi</category>
      </categories>
      <tags>
        <tag>umi</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm-node管理机制</title>
    <url>/2021/07/08/nvm-node%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="nvm是如何管理你的node版本的？"><a href="#nvm是如何管理你的node版本的？" class="headerlink" title="nvm是如何管理你的node版本的？"></a>nvm是如何管理你的node版本的？</h1><p>在你切换时他会在c盘下生成一个快捷方式，这个快捷方式会指向你当前版本的包的地址。然后系统这边的Node相关配置永远都指向这个c盘的这个生成的快捷方式即可。</p>
<p>当你删除c盘下的快捷方式时输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvm list</span><br></code></pre></td></tr></table></figure>
<p>你会发现当前没有选中的node版本。正常你在使用哪个包前面会有【*】标识。<br>可以通过这种方式来间接的去证明上述管理Node版本的机制。</p>
]]></content>
      <categories>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理</title>
    <url>/2021/06/09/%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="如何引入node-modules里面的资源的？"><a href="#如何引入node-modules里面的资源的？" class="headerlink" title="如何引入node modules里面的资源的？"></a>如何引入node modules里面的资源的？</h1><p>在项目引入被封装成一个包的样式资源时，报错。原以为是包中关于icon的后缀名有问题，发现其它项目是可以直接用。不得不怀疑是否是路径存在问题。</p>
<p>在大能的一步步指引下，终于明白我的问题点在哪了。首先我不了解这个包是如何被引进项目里的。我当时的认知停留在每个包文件下会有个入口文件，默认指向这个入口文件。这里其实还存在一个情况，如果该包里有一pakcage.json，里面有个main会指定这个包的入口文件。</p>
]]></content>
      <categories>
        <category>package</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>package</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/2021/06/08/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h1><h2 id="从上到下"><a href="#从上到下" class="headerlink" title="从上到下"></a>从上到下</h2><p>我的理解，js的对象是一层层继承过来的，每层的一些属性都会记录在由该对象构造后的新对象的_protp_属性上。</p>
<blockquote>
<p>需要说明的是，像已经被构建为某个具体的对象（如对象、数组、字符串等）是一个本身不具有constructor的对象。但是它仍能调用这个方法，原因是因为他们都是由Object对象构建而来，而它有这个构造的方法。所以如果说你新建了一个具有某个属性的对象（如 let a = {name: ‘a’}），然后通过a.constructor去构建一个新对象，本身调用的是Object的构造方法。所以它的效果跟正常声明一个空对象是一样的，如下图。</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/06/08/2BolvD.png" alt="糟糕！没有了！"></p>
<p>在取新的被构建出来的对象的某个属性时，这里分为一下几种情况。</p>
<p class="todo">有时间看看是否替换成表格能更加舒适</p>

<p>第一、<br>该对象无这个属性，且继承过程中所涉及到的类也无此属性<br>返回undefniend<br>第二、<br>该对象无这个属性，且继承过程中某个类含有此属性<br>返回通过原型链可以拿到的最近的被继承类的属性值<br>第三、<br>该对象本身具有此属性，且继承过程中的某个类也含有该属性<br>返回自身的属性值</p>
<blockquote>
<p>可看出，在获取某个属性的时候，先判断按照自己本身，如若没有就接着通过原型链来获取在继承过程中，是否中间过程有该属性的类，有则返回里这个对象最近的这个属性。</p>
</blockquote>
<p class="todo">将来补充一下关系图</p>

<h2 id="从下接着往下走"><a href="#从下接着往下走" class="headerlink" title="从下接着往下走"></a>从下接着往下走</h2><p>其实不难想象，把一个又一个还没有实例化的【类】抽象为我们熟知的类，然后将这种层层继承过来的过程想象成类的继承和实例化等，就可以通过面向对象的思路来去理解。那么js中的【类】是否可以也拥有传统面向对象的多态、继承等概念呢？<p class="todo">后期如果有了新的理解再补充。</p></p>
]]></content>
      <categories>
        <category>Java Script</category>
      </categories>
      <tags>
        <tag>Java Script</tag>
      </tags>
  </entry>
  <entry>
    <title>js观察者模式实现</title>
    <url>/2021/10/21/js%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>角色：通知者和观察者<br>通知者：有变化通知观察者<br>观察者：收到变化响应变化</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs ecmascript">// 通知者<br>class Subject &#123;<br>  constructor() &#123;<br>    this.handlerEmit = []<br>  &#125;<br><br>  notice() &#123;<br>    this.handlerEmit.forEach((fn) =&gt; fn())<br>  &#125;<br>&#125;<br><br>// 观察者A<br>class ObserverA &#123;<br>  constructor() &#123;<br>      this.handler = ()=&gt;(&#x27;console.log(handlerA)&#x27;)<br>  &#125;<br>&#125;<br><br>// 观察者B<br>class ObserverB &#123;<br>  constructor() &#123;<br>    this.handler = ()=&gt;(&#x27;console.log(handlerA)&#x27;)<br>  &#125;<br>&#125;<br><br>const obA = new ObserverA()<br>const obB = new ObserverB()<br>const subject = new Subject()<br>subject.handlerEmit.push(obA,obB)<br>subject.notice()<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在hexo中引入echarts</title>
    <url>/2021/07/21/%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%AD%E5%BC%95%E5%85%A5echarts/</url>
    <content><![CDATA[<h1 id="引入资源"><a href="#引入资源" class="headerlink" title="引入资源"></a>引入资源</h1><p>在对应ejs模板中输入以下代码，加载对应资源</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span>- js<span class="hljs-comment">(&#x27;https://cdnjs.cloudflare.com/ajax/libs/echarts/5.1.2/echarts.min.js&#x27;)</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的cdn可以在网上搜索然后获取相应的cdn连接。这里用的是<a href="https://cdnjs.com/libraries/echarts">https://cdnjs.com/libraries/echarts</a></p>
</blockquote>
<h1 id="在对应ejs模板中写入逻辑"><a href="#在对应ejs模板中写入逻辑" class="headerlink" title="在对应ejs模板中写入逻辑"></a>在对应ejs模板中写入逻辑</h1><ol>
<li>将写好的逻辑放入静态资源js目录下</li>
<li>在对应想展示的ejs模板中加入如下元素，在加上echarts相应的代码</li>
</ol>
<blockquote>
<p>可参考官网上的示例<a href="https://echarts.apache.org/zh/tutorial.html">https://echarts.apache.org/zh/tutorial.html</a></p>
</blockquote>
<figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">&lt;<span class="hljs-keyword">div</span> <span class="hljs-symbol">id</span>=<span class="hljs-string">&quot;echartsDom&quot;</span> style=<span class="hljs-string">&quot;height:400px;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;%- js(<span class="hljs-string">&#x27;js/echarts/index.js&#x27;</span>) %&gt;<br></code></pre></td></tr></table></figure>

<p>效果如下<br><img src="https://z3.ax1x.com/2021/07/21/Wd6K9H.png" alt="Wd6K9H.png"></p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库选型</title>
    <url>/2021/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>ACID，是指数据库管理系统（DBMS）在寫入或更新資料的過程中，為保證事务（transaction）是正確可靠的，所必須具備的四个特性：原子性（atomicity，或稱不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p>
<table>
<thead>
<tr>
<th>VS</th>
<th>PostgreSQL</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>开源</td>
<td>PostgreSQL是一个免费的开源系统，它受PostgreSQL许可证（自由的开源许可证）的约束。</td>
<td>MySQL属于Oracle旗下产品，并提供几种付费版本供用户使用</td>
</tr>
<tr>
<td>管理</td>
<td>PostgreSQL是全球用户共同发展的产品</td>
<td>MySQL是GNU通用公共许可以及各种专有协议条款下的产品</td>
</tr>
<tr>
<td>性能</td>
<td>PostgreSQL适合对读写速度要求很高的大型系统中使用</td>
<td>MySQL主要用于Web应用程序，该Web应用程序仅需要数据库来进行数据交易。</td>
</tr>
<tr>
<td>遵循ACID</td>
<td>PostgreSQL从头到尾都遵循ACID原则，并确保满足需求</td>
<td>MySQL只有在使用InnoDB和NDB集群存储引擎时才符合ACID要求。</td>
</tr>
<tr>
<td>SQL 兼容性</td>
<td>“从文档看，PostgreSQL是兼容大部分SQL的。 PostgreSQL支持SQL:2011的大多数功能。在核心一致性所需的179个强制性功能中，PostgreSQL至少兼容160个。此外，还有一系列受支持的可选功能。”</td>
<td>“从文档看，MySQL在某些版本是兼容部分SQL。 我们对该产品的主要目标之一是继续努力达到SQL标准的要求，但又不牺牲速度或可靠性。我们可以添加SQL扩展或对非SQL功能的支持，如果这样可以极大地提高MySQL服务器在我们大部分用户群中的可用性。”</td>
</tr>
<tr>
<td>支持平台</td>
<td>PostgreSQL可以运行在Linux, Windows (Win2000 SP4 及以上)，FreeBSD，OpenBSD，NetBSD , Mac OS X, AIX, IRIX ,Solaris和 Tu64. 也支持由技术巨头惠普开发的HP-UX OS，以及开源的Unix OS。</td>
<td>MySQL可以运行在Oracle Solaris，Microsoft Windows, Linux Mac OS X。MySQL扩展了对开源FreeBSD OS的支持</td>
</tr>
<tr>
<td>编程语言支持</td>
<td>PostgreSQL是用C语言编写的，它支持多种编程语言，最突出的C/C++, Delphi, JavaScript, Java, Python, R , Tcl , Go, Lisp, Erlang和.Net.</td>
<td>PostgreSQL是用C和C++编写的，它支持C/C++, Erlang，PHP，Lisp,和Go, Perl，Java, Delphi, R ,和 Node.js.</td>
</tr>
<tr>
<td>物化视图</td>
<td>PostgreSQL支持物化视图</td>
<td>MySQL不支持物化视图</td>
</tr>
<tr>
<td>数据备份</td>
<td>PostgreSQL支持主备复制，并且还可以通过实现第三方扩展来处理其他类型的复制</td>
<td>MySQL支持主备复制，其中每个节点都是主节点，并且有权更新数据</td>
</tr>
<tr>
<td>可拓展性</td>
<td>PostgreSQL是高度可扩展的，您可以添加和拥有数据类型，运算符，索引类型和功能语言。</td>
<td>MySQL不支持拓展性。</td>
</tr>
<tr>
<td>访问方法</td>
<td>PostgreSQL支持所有标准。</td>
<td>MySQL支持所有标准。</td>
</tr>
<tr>
<td>社区支持</td>
<td>PostgreSQL有一个活跃的社区支持，该社区帮助改善现有功能，其富有创造力的提交者竭尽全力确保该数据库保持最新的功能和最大的安全性，成为最先进的数据库。</td>
<td>MySQL也有一个庞大的追随者社区，这些社区贡献者，特别是在被Oracle收购之后，主要关注一些偶尔出现的新功能，并维护现有功能。</td>
</tr>
<tr>
<td>安全性</td>
<td>PostgreSQL为连接提供本机SSL支持，以加密客户端/服务器通信。 PSQL还具有行级安全性。</td>
<td>MySQL是高度安全的，并且包含多个安全功能。</td>
</tr>
</tbody>
</table>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-1</title>
    <url>/2021/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/</url>
    <content><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><ol>
<li>有序的</li>
<li>每次一分为二</li>
<li>目标数量越多，优势越大</li>
<li>复杂度O(logn)<blockquote>
<p>n个目标对象中利用二分法查找某个值 = (2的几次方 = n)</p>
</blockquote>
</li>
</ol>
<p>下图为二分（log2n）和正常按顺序去计算（y=x）的图像。在大于0的情况，也就是实际中任何情况下二分法的计算次数会小于线性。<br><img src="https://z3.ax1x.com/2021/07/12/WPYbuQ.png" alt="WPGG5V.png"></p>
<h1 id="O分析算法速度"><a href="#O分析算法速度" class="headerlink" title="O分析算法速度"></a>O分析算法速度</h1><ul>
<li>是什么？<br>在目标数据量为n时，该功能模块需要做几次运算，是衡量算法的性能的一个衡量标准。</li>
<li>作用<br>衡量算法的性能。</li>
</ul>
<h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><blockquote>
<p>可以将所存取的元素想象为一个个将要寄存在货柜。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>中间插入时会优于链表。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每次都会从内存中取出单位长度的空间</p>
<ol>
<li>如若当前要插入的东西大于这个单位则会往后窜超出的部分。这个情况下的计算会很浪费时间。</li>
<li>如若小于这个单位，则这些多余的空间会造成浪费，别人无法使用。</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>链表可以用来创建更高级的数据结构</p>
</blockquote>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>删除和插入元素等操作要比数组简单。</li>
</ol>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>正常存、然后通过指针来联系各个元素之间的对应关系：</p>
<ol>
<li>可以是有方向的，顺序的-【链表】</li>
<li>也可以是闭环的等-【图】</li>
<li>可以是一对多，想树一样的分支-【树】</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可以解决数组的空间开辟问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-2</title>
    <url>/2021/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>每次选择基准值<br>根据基准值进行排序<br>最糟糕情况需要遍历全部</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>速度快，时间不会超过n^2</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>O(nlogn)<br><img src="https://z3.ax1x.com/2021/07/26/WRbFRx.png" alt="WRIgje.png"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>系统自带的排序为快排</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h2><ul>
<li>跳出条件</li>
<li>执行逻辑</li>
<li>找到下一个元素，调用自己，知道找到元素或跳出。</li>
</ul>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>找出基线条件，找出可抽象最基本处理规则。</li>
<li>可以通过反复进行在上述规则处理从而得出最终结果。</li>
</ol>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p>是一个按照某个分类平均分布的链表结构。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>对节点的操作复杂度低。</p>
<h1 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h1><h2 id="egg"><a href="#egg" class="headerlink" title="egg"></a>egg</h2><h3 id="找到途径车站最少的路径"><a href="#找到途径车站最少的路径" class="headerlink" title="找到途径车站最少的路径"></a>找到途径车站最少的路径</h3><ol>
<li>找到只经过一个站点能到达的地方</li>
<li>判断一个站点所能达到的地方是否包含重点，否则继续找两个站点能到达的地方<br>直到n个站点所能到达的地方包括终点。</li>
</ol>
<h1 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h1><p class="todo">名字不记得了，回去补充</p>

<h3 id="找到途径时间最少的路径"><a href="#找到途径时间最少的路径" class="headerlink" title="找到途径时间最少的路径"></a>找到途径时间最少的路径</h3><blockquote>
<p>每个边有权重，这个例子的权重就是两站之间所花费的时间</p>
</blockquote>
<p>记录每个站点的权重，然后找出时间花费最少的接着计算由他分散出去的各个节点的时间。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-3</title>
    <url>/2021/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-3/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>  对于某个目的的快速落地方案。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>求近似值。</li>
<li>时间快</li>
</ul>
<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><p>在众多要求中，优先选择核心的条件，是一个取舍问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-想法记录</title>
    <url>/2021/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%83%B3%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="关于查找的想法"><a href="#关于查找的想法" class="headerlink" title="关于查找的想法"></a>关于查找的想法</h1><h2 id="想法-散列表是二维的二分法"><a href="#想法-散列表是二维的二分法" class="headerlink" title="想法-散列表是二维的二分法"></a>想法-散列表是二维的二分法</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>排序、通过二分法查找</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>将树洗成左子树的权重始终比右子树大的这种排列方式，然后从中间开始找。树结构的二分法。</p>
<h3 id="扩展（纯属自己没事瞎想）"><a href="#扩展（纯属自己没事瞎想）" class="headerlink" title="扩展（纯属自己没事瞎想）"></a>扩展（纯属自己没事瞎想）</h3><ul>
<li>如果有一个二维数组，第一个维度按照权重大小排序生成一个映射关系m1，在根据第二个维度的权重大小生成一个映射关系m2，然后查找m1维度权重为m(n)，m2维度权重为m(o)为的元素,也就是m1(n)m2(o)，通过两个分发去查找。适合多维度数据的查找与操作。不适合精确查找，除非这个元素已知，或者范围查询。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人问题总结</title>
    <url>/2021/06/09/%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>急躁，遇事先思考。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><input type="checkbox" value="check1" id="check1">
<label for="check1" class="mark">1. 专注呼吸，调整心态。</label >
<input type="checkbox" value="check2" id="check2">
<label for="check2" class="mark">2. 思考着急是为了什么？是否重要？为什么要给自己压力？</label >
<input type="checkbox" value="check3" id="check3">
<label for="check3" class="mark">3. 做什么事情尽量慢一个步调，想象自己是一个慢悠悠的性子。</label >
<input type="checkbox" value="check4" id="check4">
<label for="check4" class="mark">4. 可以适当的辅助一些运动。</label >
<input type="checkbox" value="check5" id="check5">
<label for="check5" class="mark">5. 每当做出决定前先考虑是否可以这么做？这么做的好处是什么？这么做是否有意义？</label >
]]></content>
      <categories>
        <category>个人提升</category>
        <category>每日打卡</category>
      </categories>
      <tags>
        <tag>个人提升</tag>
        <tag>每日打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器</title>
    <url>/2021/06/08/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="当在地址栏输入一个url后会发生什么？"><a href="#当在地址栏输入一个url后会发生什么？" class="headerlink" title="当在地址栏输入一个url后会发生什么？"></a>当在地址栏输入一个url后会发生什么？</h1><ol>
<li>首先会解析域名，找到正确的ip地址，访问服务器。（此服务器为web服务器，如nginx）</li>
<li>nginx会找对应的前端项目中获取html、css、js等资源。</li>
<li>浏览器开始加载资源，如果js里有死循环可能会造成阻塞。</li>
<li>在资源加载完毕后，如有ajax，ajax是浏览器层单独新建的一个进程，故在请求前后是不会阻塞</li>
<li>ajax请求后，如有根据请求回的数据进行死循环，之前实现效果为不阻塞。（这个有待详细实验）</li>
</ol>
<p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;div1&#x27;</span>&gt;</span>div1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#div1</span>&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-string">&#x27;red&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span> = <span class="hljs-title">setInterval</span>(<span class="hljs-params">()=&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>).style.backgroundColor = <span class="hljs-string">&#x27;blue&#x27;</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-number">1000</span></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 假设<span class="hljs-title">ajax</span>是一个请求<span class="hljs-title">ajax</span>的异步函数 </span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span> = <span class="hljs-title">ajax</span>(<span class="hljs-params">res</span>)</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">while</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>) </span>&#123;<br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>).style.backgroundColor = <span class="hljs-string">&#x27;green&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器获取资源</title>
    <url>/2021/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近开发的项目中有个奇怪的现象。<br>每次更新镜像，获取资源时如果在未获取完时刷新就会导致资源长时间获取被截断。（对资源大的有有明显影响）</p>
<h1 id="触发现象"><a href="#触发现象" class="headerlink" title="触发现象"></a>触发现象</h1><p>更新镜像时在模块未加载时更新</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li>更新镜像会导致线上对应的资源会更新。</li>
<li>获取数据时按照之前的方式获取。</li>
<li>刷新导致之后的资源还是用之前错误的方式获取。</li>
<li>浏览器dns解析时会有一些缓存，可以试着猜想一下请求的缓存时的相应旧的请求方式是否也会缓存在计算机中。下回遇到可以尝试清系统缓存看看。</li>
</ol>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><ol>
<li>减小大资源。可通过打包时的相应配置去控制。</li>
<li>了解其机制，从根本原因下手。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-概览</title>
    <url>/2021/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="解决问题思路"><a href="#解决问题思路" class="headerlink" title="解决问题思路"></a>解决问题思路</h1><p>解决思路</p>
<p><img style="width: 40%" src="https://z3.ax1x.com/2021/07/06/R7Dejf.png"></img></p>
<h1 id="学习图谱"><a href="#学习图谱" class="headerlink" title="学习图谱"></a>学习图谱</h1><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>学习图谱<ul>
<li>基础<ul>
<li>基本数据结构</li>
<li>大O(如何看复杂度)</li>
</ul>
</li>
<li>解决问题<ul>
<li>散列表</li>
<li>图</li>
<li>分治</li>
<li>动态规划</li>
<li>贪心</li>
</ul>
</li>
<li>进一步学习其他10种算法</li>
</ul>
</li>
</ul>
</blockquote>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络学习笔记</title>
    <url>/2021/06/07/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-数据是如何传输的"><a href="#1-数据是如何传输的" class="headerlink" title="1. 数据是如何传输的"></a>1. 数据是如何传输的</h1><h2 id="1-网络传输过程"><a href="#1-网络传输过程" class="headerlink" title="1. 网络传输过程"></a>1. 网络传输过程</h2><ol>
<li>应用层<br>传递消息</li>
<li>表示层<br>解密、编码等</li>
<li>会话层<br>维持会话</li>
<li>传输层<br>端对端的链接</li>
<li>网络层<br>网络层收到传输层来的数据，加入路由信息，地址信息等，形成“包”。这些包就会在网络中传播（中间可能跳转多个路由器），到达对方的网络</li>
<li>数据链路层<br>上层协议转换成lan地址，把消息换成“位”，主要进行<div class="text_need_explain">ARP<div class="text_explain">地址解析协议</div></div>等协议，加入本网中表示你PC的字段</li>
<li>物理层<br>按照位在你网线中发送高低电压的信号</li>
</ol>
<blockquote class="pullquote mindmap mindmap-md"></blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2021/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式是什么"><a href="#策略模式是什么" class="headerlink" title="策略模式是什么?"></a>策略模式是什么?</h1><p>我的理解是：对变化的封装</p>
<p>多个策略封装，根据判断条件实例化对应策略。<br><img src="https://z3.ax1x.com/2021/08/02/fpRyBF.jpg" alt="fpC5qO.png"></p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>可以方便的切换变化的部分。</p>
<p>例子（引自《大话设计模式》）：<br>某超市的促销活动在不同场景下优惠的策略不同,可将这些策略封装起来，在根据调用的具体逻辑去实例化。<br><img src="https://z3.ax1x.com/2021/08/02/fp42qK.jpg" alt="fpC5qO.png"></p>
<blockquote>
<p>我认为比较合理的封装是将策略进行分类，日后如有具体的需求可以在原有分类上继承并添加具体策略的成员变量和方法。</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/08/02/fpfzTg.png" alt="fpC5qO.png"></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p class="todo">有想法再补充</p>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>路由的实现</li>
</ol>
<ul>
<li>react-router</li>
<li>vue-router</li>
<li>egg-router</li>
<li>koa-router</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>策略模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统-概述</title>
    <url>/2021/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="计算机由硬件-amp-系统软件组成"><a href="#计算机由硬件-amp-系统软件组成" class="headerlink" title="计算机由硬件&amp;系统软件组成"></a>计算机由硬件&amp;系统软件组成</h1><ul>
<li>系统中所有信息-包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据都是由一串位表示的。</li>
</ul>
<h1 id="程序翻译执行过程"><a href="#程序翻译执行过程" class="headerlink" title="程序翻译执行过程"></a>程序翻译执行过程</h1><p>ASCII文本 -&gt; 二进制可执行文件（编辑器、链接器翻译） </p>
<p><img src="https://z3.ax1x.com/2021/07/22/WBznyQ.png" alt="WBxwPf.png"></p>
<h2 id="计算机运行程序时的图解"><a href="#计算机运行程序时的图解" class="headerlink" title="计算机运行程序时的图解"></a>计算机运行程序时的图解</h2><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><h1 id="操作系统内核是应用程序和硬件之间的媒介"><a href="#操作系统内核是应用程序和硬件之间的媒介" class="headerlink" title="操作系统内核是应用程序和硬件之间的媒介"></a>操作系统内核是应用程序和硬件之间的媒介</h1><ol>
<li>文件是对 I/O设备的抽象</li>
<li>虚拟存储器是对主存的和磁盘的抽象</li>
<li>进程是对处理器、主存和I/O设备的抽象</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>大前端-个人提升角度分析</title>
    <url>/2021/05/27/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-前端所占比重"><a href="#1-前端所占比重" class="headerlink" title="1. 前端所占比重"></a>1. 前端所占比重</h2><p>比重：往往懂前端的而后端且先到更容易有较高地位。</p>
<p> to c 前后端都无地位。</p>
<p>引出观点：无论前后端，都需要具备全站的知识涵盖范围。</p>
<h2 id="2-团队规模决定前端"><a href="#2-团队规模决定前端" class="headerlink" title="2. 团队规模决定前端"></a>2. 团队规模决定前端</h2><p>决定因素：&gt; 业务体量  &gt; 团队规模</p>
<h2 id="3-流水线式开发"><a href="#3-流水线式开发" class="headerlink" title="3. 流水线式开发"></a>3. 流水线式开发</h2><p>大型组织，需要更明确的分工，以便于机械工的生产更多的应用。</p>
<p>也因此需要更明确的分工，来解决效率的问题。</p>
<p>工具支撑团队<br>框架开发团队<br>业务开发团队<br>DevOps 团队</p>
<h2 id="4-客户端多样式"><a href="#4-客户端多样式" class="headerlink" title="4. 客户端多样式"></a>4. 客户端多样式</h2><p>客户端开发的需求：微信小程度、桌面客户端、跨平台应用等等。</p>
<h2 id="5-新的领域"><a href="#5-新的领域" class="headerlink" title="5. 新的领域"></a>5. 新的领域</h2><p>新的领域，存在更多机会。</p>
<p>边缘计算<br>区块链<br>客户端计算<br>……</p>
<h2 id="6-业务熟悉度"><a href="#6-业务熟悉度" class="headerlink" title="6. 业务熟悉度"></a>6. 业务熟悉度</h2><p>业务不熟悉无法带领团队。</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>大前端-是什么？</title>
    <url>/2021/05/27/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>是什么：通过Web 开发相关的技术（WebView、JavaScript/TypeScript）所能开发、处理的领域。</p>
<p>涵盖领域：后端（Node.js 如 BFF 层、Serverless）、HTML 5 游戏、物联网、嵌入式应用、移动应用、桌面应用。</p>
<p>特点：一次开发，多种平台</p>
<h2 id="2-为什么是大前端，不是大后端呢？"><a href="#2-为什么是大前端，不是大后端呢？" class="headerlink" title="2. 为什么是大前端，不是大后端呢？"></a>2. 为什么是大前端，不是大后端呢？</h2><ol>
<li><p>前端，即面向用户交互，存在一系列的方式。</p>
</li>
<li><p>前端在变窄</p>
</li>
<li><p>JavaScript 易学、广泛使用、熟悉的语法</p>
</li>
<li><p>无处不在的 WebView</p>
</li>
</ol>
<blockquote>
<p>值得注意的是：对于某些领域而言，大前端技术并不是最好的技术，但是它是实现起来最快的技术，也因此特别适合于 MVP 原型构建。与此同时，前端技术的动态特性，特别适合于远程更新业务——只需要更新对应的代码，而不需要更新整个应用。</p>
</blockquote>
<h2 id="3-大前端的技术领域"><a href="#3-大前端的技术领域" class="headerlink" title="3. 大前端的技术领域"></a>3. 大前端的技术领域</h2><ol>
<li> Web 前端</li>
<li> GUI</li>
<li> 游戏</li>
<li> 物联网</li>
<li> 移动端</li>
<li> AR/VR</li>
</ol>
<h2 id="4-如何成为大前端？"><a href="#4-如何成为大前端？" class="headerlink" title="4. 如何成为大前端？"></a>4. 如何成为大前端？</h2><p>所谓的前端 in 后端，便是在后端开发中，使用前端相关的语言和技术栈。最典型的场景，便是使用 Node.js 开发后端服务。</p>
<h2 id="5-服务端渲染"><a href="#5-服务端渲染" class="headerlink" title="5. 服务端渲染"></a>5. 服务端渲染</h2><p>JavaScript，它的动态语言特性，非常适合于快速开发应用。于是乎，我们便有了服务端渲染。</p>
<h3 id="模式：模板渲染"><a href="#模式：模板渲染" class="headerlink" title="模式：模板渲染"></a>模式：模板渲染</h3><p>在早期，前端开发人员使用的是数据、代码与模板分离的设计，诸如在 Java 里使用 Mustache 来进行服务端渲染。</p>
<p>而随着前端技术的发展，代码和模板往往糅合在一起。</p>
<h3 id="模式：异构渲染"><a href="#模式：异构渲染" class="headerlink" title="模式：异构渲染"></a>模式：异构渲染</h3><h4 id="Node-js-打造后端服务"><a href="#Node-js-打造后端服务" class="headerlink" title="Node.js 打造后端服务"></a>Node.js 打造后端服务</h4><p>从社区的探索来看，存在一些完全使用 Node.js 开发的后台服务。但是，也存在一系列由于代码不规范造成的问题。从社区的经验来看，Node.js + Express + MongoDB + Angular/Vue/React，便是一些不错的选择。当然了，也有相当多的应用，只是采用了 Node.js 来完成 BFF 层（Backend For Frontends）。在这一层业务上，它只做业务数据的中间处理。</p>
<p>一些关键的节点上，尽量不要采用 Node.js 来打造后台服务。除了涉及到 SPA 的服务端渲染，不得不使用 Express、Koa 等这样的服务端 JavaScript/TypeScript 框架，来解决这样的问题。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>Express<br>Koa<br>Egg.js<br>NestJS<br>Hapi.js<br>Sails.js</p>
<h3 id="是否大规模采用？"><a href="#是否大规模采用？" class="headerlink" title="是否大规模采用？"></a>是否大规模采用？</h3><p>国内最大规模使用 Node.js 开发后端服务的团队是阿里巴巴：</p>
<p>Node 的 Collaborator 有 5 个国人, 其中 4 个在阿里巴巴这边，并且有国内唯一一个 CTC 成员。</p>
<h2 id="6-FaaS-amp-Serverless"><a href="#6-FaaS-amp-Serverless" class="headerlink" title="6. FaaS &amp; Serverless"></a>6. FaaS &amp; Serverless</h2><blockquote>
<p>Serverless 架构是指大量依赖第三方服务（也叫做后端即服务，即“BaaS”）或暂存容器中运行的自定义代码（函数即服务，即“FaaS”）的应用程序，函数是无服务器架构中抽象语言运行时的最小单位。在这种架构中，并不看重运行一个函数需要多少 CPU 或 RAM 或任何其他资源，而是更看重运行函数所需的时间，只为这些函数的运行时间付费。</p>
</blockquote>
<p>对于没有后台经验的前端开发人员来说，使用 Node.js 开发后端应用是一种相当大的挑战。大多数非科班的前端程序员，不知道从数据库到 RESTful API 的一系列操作，并且还需要了解到部署等一系列的系统底层知识。因此，使用 Serverless 这种不关心基础设施的技术，可以进一步地降低开发成本。</p>
<p>采用 Serverless 架构，也就意味着，我们提取出了大量的基础设施。而使用 Node.js + JavaScript 作为胶水，来快速连接不同的服务，以形成一个快速有效的方案。并且，编写更少的代码，也意味着更安全、快速。</p>
<p>使用 AWS 来运行大量的 Serverless 计算的成本很高，但是自己搭建一个 Serverless 服务器，来运行自己的 Serverless 应用，则变成了一种更廉价的方式。除了直接基于 AWS 的 Serverless Framework 框架的方案，还有 OpenFaaS、Kubeless、OpenWhisk、Fission 等不同的 Serverless 框架。</p>
<h2 id="7-API-Gateway-amp-BFF"><a href="#7-API-Gateway-amp-BFF" class="headerlink" title="7. API Gateway &amp; BFF"></a>7. API Gateway &amp; BFF</h2><h3 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h3><p>BFF，即 Backends For Frontends (服务于前端的后端)，也就是服务器设计 API 时会考虑客户端的使用情况，在服务端根据不同的设备类型，返回不同客户端所需要的结果。BFF 模式，这种模式不会为所有的客户端创建通用的 API。而是创建多个 BFF 服务：一个用于 Web 前端、一个用于移动客户端（甚至一个用于 iOS，另一个用于 Android）等等。</p>
<h2 id="8-大前端：IoT"><a href="#8-大前端：IoT" class="headerlink" title="8. 大前端：IoT"></a>8. 大前端：IoT</h2><p>Web 应用的架构相比于一个物联网系统，无非就是多了一层硬件层以及可选的协调层。</p>
<h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><h2 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h2><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2>]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2021/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式是什么"><a href="#工厂模式是什么" class="headerlink" title="工厂模式是什么?"></a>工厂模式是什么?</h1><p>我的理解是：封装最基本的单元</p>
<p>比如有一个工具箱，我们可以把工具箱里的每个工具封装成一个类，在使用某个工具是实例化这个工具。<br><img src="https://z3.ax1x.com/2021/08/02/fpC5qO.png" alt="fpC5qO.png"><br>这个工具可以手工的diy，也就是具备老旧工具功能的新工具。</p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>可以方便的那这些零件去拼凑出自己想要的工具，增加代码可复用。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p class="todo">有想法再补充</p>]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>高数-函数</title>
    <url>/2021/07/20/%E9%AB%98%E6%95%B0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h1><p>x -&gt; f(x) 只有一个</p>
<h1 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h1><h1 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h1>]]></content>
      <categories>
        <category>高数</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
